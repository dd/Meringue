# Functional



## gc_project.go_core

базовый пакет, утилиты и прочая лабуда.

python3.6


### Install

1. **gc_project.go_core** и **django_mobile** в **INSTALLED_APPS**


### Models

**PublishedMixin** - добавляет поле is_published и переопределяет стандартный менеджер добавляя фильтр Foo.objects.published() для фильтрации опубликованных записей

**CMTimeMixin** - добавляет в модель поля ctime и mtime


### Utils

#### Thumbnail

**get_thumbnail** - простой генератор превью, передаётся путь к изображению и последовательный список применяемых модификаторов. Последовательность действий соответствует последовательности введённых аргументов т.е. последовательность - ['s:600x400','resize','s:400x400','crop'] - сначала задас целевой размер изображения 600x400, далее скукожит (или растянет изображение в зависимости от исходного и других параметров) до 600x400, потом установит новый целевой размер 400x400 и отрежет лишнее.

возможные агрументы:

* *s:\<width\>x\<height\>* - указывает целевой размер изображения для последующих функций
* *maxw:\<width\>* - указывает максимальную ширину
* *crop* - изменения размера холста до последнего установленного
* *resize* - изменение размера изображения до последнего установленного
* *q:\<quality\>* - укажет качество конечного изображения 0-100 (используется в последний момент при сохранении)
* *c:\<color\>* - цвет заливки для кропа в формате rgba (c:255 255 255 255)
* *rm:cover|contain|stretch* - метод ресайза вписать в размер или растянуть
* *cm:left|center|rigth top|center|bottom* - точка отсчёта для кропа

> дефолтные конфиги смотреть в gc_project/configuration.py

**How to**

```python
from gc_project.go_core.utils import get_thumbnail
...
file_url = get_thumbnail(filename=filename, task_list=task_list)
```

**TO-DO**:
1. watermark (заранее готовое решение)
2. определение лица и использование в роли центра изображения
3. указание максимальной ширины или высоты, без указания минимальной
4. определение фокуса изображения


### Templatetags

#### gc_base

**cop_year** - диапазон годов для копирайтов (год отсчёта задаётся в settings в параметре **GC_START_YEAR**)

**date_range** - диапазон дат (DD - DD.MM.YYYY || DD.MM - DD.MM.YYYY || DD.MM.YYYY - DD.MM.YYYY)

**How to**

```jinja2
{% load gc_base %}
...
{% cop_year %}
{% date_range date1 date2 %}
```


#### gc_thumbnails

**thumbnail** - простой генератор превью, обёртка под утилиту thumbnail

**How to**

```jinja2
{% load gc_thumbnails %}
...
{{ object.image.path|thumbnail:"s:600x400,crop" }}
```


### Upload Handlers

**MemoryFileUploadHandler** и **TemporaryFileUploadHandler** - новые загрузчики переименовывающие загружаемые файлы. По дефолту новое имя - uuid.uuid4(), но функцию переименования можно задать свою в settings в поле **GC_UPLOAD_RENAME_HANDLER**

**How to**

что бы включить необходимо в settings добавить:

```python
FILE_UPLOAD_HANDLERS = (
    'gc_project.go_core.upload_handlers.MemoryFileUploadHandler',
    'gc_project.go_core.upload_handlers.TemporaryFileUploadHandler',
)
```


### Translation

В стандартные джанговские Meta добавлено поле **translate_fields** для указания полей для перевода, после чего остаётся только указать какие модели вообще нужно переводить в файлах models.py в списке translate_models

**Example**

```python
translate_models = [
    'Foo',
]

class Foo(models.Model):
    title = models.CharField(verbose_name=_('Название'), max_length=255)

    class Meta:
        translate_fields = ['title', ]
```

**How to**

что бы всё заработало в settings указать:

```python
MODELTRANSLATION_TRANSLATION_REGISTRY = 'gc_project.go_core.translation'
```

**TO-DO**:
1. наверное стоит мониторить все существующие модели на наличие ууказаных полей в мета, так будет ещё круче



## gc_project.go_admin

пакет для админки, стили и класс для модели с переводом.


### Install

1. **gc_project.go_admin** в **INSTALLED_APPS**
2. **gc_project.go_admin.context_processors.base** в **TEMPLATES** **OPTIONS.context_processors**



## gc_project.go_nike

Содержит стили для адмики и шаблон с подключением http://www.nike.com/styleguide/docs/


### Install

1. **gc_project.go_nike** в **INSTALLED_APPS**

**How to**

Что бы заработали стили в админке, во первых нужно gg_project.go_admin включить до django.contrib.admin, а так же в стилях pipline прописать admin.nike_theme:

```python
'admin.nike_theme': {
    'source_filenames': (
        'gc/styles/go_nike.admin_theme.sass',
    ),
    'output_filename': 'gc/css/go_nike.admin_theme.min.css'
},
```

Что бы использовать стили в своих шаблонах нужно заинклудить includes/nike_styles.html



## gc_project.go_mail

приложение для управления почтовыми рассылками


### Install

1. **gc_project.go_mail** в **INSTALLED_APPS**
2. **from gc_project.go_mail.urls import urlpatterns as gcm_urlpatterns** и **url(r'', include(gcm_urlpatterns))** в **urls**
3. установить [pycrypto][1] версии 2.6.1 (или любой другой совместимой, разбирайся сам) - **pip install pycrypto==2.6.1**
4. провести миграции - **python manage.py migrate**


### Configurating

Для генератора ссылок (к примеру ссылку на вебверсию письма) нужны протокол и домен:

```python
GC_PROTOCOL = "gocream.ru"
GC_DOMAIN = "https"
```

А так же можно указать 32-х значный ключ, дефолтное значение - первые 32 символа секретного ключа проекта

```python
GC_CRYPTO_KEY = "<32_crypto_key>"
```


### Models

**Distribution** - самая интересная для нас часть этого пакета.

> структуру смотри в репе

**Методы**:

- **send** - рассылка, тут всё понятно, запускаешь, начинается рассылка

> пока рассылка происходит одним потоком, нужно сделать её во первых откуда нибудь из редиса, и в несколько потоков или что нибудь подобное

- **get_email_webversion_url** - ссылка на вебверсию письма


**Методы менеджера модели**:

- **create_and_send** - метод создающий и сразу же отправляющий письмо. всё просто, передаются все данные, он их сохраняет и тут же отправляет письмо.


### Templatetags

#### gc_mail_static

**gc_mail_static** - обёртка под стандартный тег {% static '' %} добавляющая домен и протокол к результату


### Utils

#### admin

**email_button_factory** - функция создающая поле для модели админки (ModelADmin) отправляющую письмо.

**Example**

```python
@admin.register(models.Foo)
class FooAdmin(admin.ModelAdmin):
    list_display = ('__str__', 'send_mail_button')
    send_mail_button = email_button_factory(url=lambda i: reverse('api:send_mail_button', kwargs={'pk': i.pk}))
```

что бы кнопку вывести на странице редактирования объекта нужно будет указать её в списке readonly_fields:

```python
@admin.register(models.Foo)
class FooAdmin(admin.ModelAdmin):
    list_display = ('__str__', 'send_mail_button')
    fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('username', 'email', 'send_mail_button'),
        }),
    )
    readonly_fields = ('send_mail_button', )
    send_mail_button = email_button_factory(url=lambda i: reverse('api:send_mail_button', kwargs={'pk': i.pk}))
```

**How to**

Для работы нужно дополнительно подключить go_admin, в списке подключённых приложений админка должна быть раньше стандартной джанговской админки, что бы подгружались нужные шаблоны. Так же, необходимо настроить статику:

```python
PIPELINE = {
    'STYLESHEETS': {
        'admin': {
            'source_filenames': (
                ...
                'gc/styles/go_mail.admin.sass',
                ...
            ),
            'output_filename': 'css/admin.main.css'
        },
    },

    'JAVASCRIPT': {
        'admin': {
            'source_filenames': (
                ...
                'gc/js/go_mail_admin.js',
                ...
            ),
            'output_filename': 'js/admin.min.js'
        },
    },

    'COMPILERS': (
        'pipeline.compilers.sass.SASSCompiler',
    ),
}
```

> используется pipeline
> не тупи, стили указывать не обязательно, но если уазывать то они написаны на sass

**Аргументы вызова**:

- url - единтвенный обязательный аргумент - ссылка на бекенд который необходимо дёргать. либо строка либо функция принимающая единственный аргумент - объект
- model - Модель рассылки, по дефолту - gc_project.go_mail.models.Distribution
- check_func - призна/функция проверки возможности отправки сообщения. Если не укзывать то у объекта ищет методы в следующем порядке:
    1. 'can_send_email'
    2. 'can_send_{name}'.format(name=model._meta.model_name)
- label - название поля в админке, дефолтное значение model._meta.verbose_name


**TO-DO**:
1. Добавить статус
2. Прикрутить ассинхронность
3. Загрузку получателей из csv, json, xls и прочее
4. Добавить статистику



## gc_project.go_sitestructure

По возможности простая но функциональная структура сайта, местами скопипащена с wagtail. Разные типы страниц создаются основываясь на базовой моделе страницы - gc_project.go_sitestructure.models.Page. В оной есть метод get_context для задания контекста при рендере страницы.


### Install

1. **gc_project.go_sitestructure** и **django_mobile** в **INSTALLED_APPS**
2. **gc_project.go_sitestructure.middlewares.Site** и **gc_project.go_sitestructure.middlewares.RedirectMiddleware** в MIDDLEWARE_CLASSES
3. **gc_project.go_sitestructure.context_processors.base** в context_processors
<!-- 4. **from gc_project.go_mailing.urls import urlpatterns as gcm_urlpatterns** и **url(r'', include(gcm_urlpatterns))** в urls (include нужно ставить в конец urlpatterns) -->









[1]: https://pypi.python.org/pypi/pycrypto
